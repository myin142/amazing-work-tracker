/* tslint:disable */
/* eslint-disable */
/**
 * Time Booking
 * Time Booking API for IMS
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: tobias.demmer@it-experts.at
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface DELETEProjectTimeBookingResponse
 */
export interface DELETEProjectTimeBookingResponse {
    /**
     * Project time spans
     * @type {Array<ProjectDateTimeSpans>}
     * @memberof DELETEProjectTimeBookingResponse
     */
    'projectTimeSpans'?: Array<ProjectDateTimeSpans>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ErrorCodeEnum = {
    ExistingProjectBookings: 'EXISTING_PROJECT_BOOKINGS',
    OverlappingTime: 'OVERLAPPING_TIME',
    TimeOutOfBounds: 'TIME_OUT_OF_BOUNDS',
    TimeLimitExceeded: 'TIME_LIMIT_EXCEEDED',
    IllegalTimeBounds: 'ILLEGAL_TIME_BOUNDS',
    UnbookedTime: 'UNBOOKED_TIME',
    OperationNotPermitted: 'OPERATION_NOT_PERMITTED',
    IllegalDate: 'ILLEGAL_DATE',
    ValidationError: 'VALIDATION_ERROR',
    ExistingVacation: 'EXISTING_VACATION',
    ExistingOffDuty: 'EXISTING_OFF_DUTY',
    ExistingSickLeave: 'EXISTING_SICK_LEAVE',
    ExistingTimeBookingEntries: 'EXISTING_TIME_BOOKING_ENTRIES',
    UserLocked: 'USER_LOCKED',
    BossLocked: 'BOSS_LOCKED',
    ProjectNotFound: 'PROJECT_NOT_FOUND'
} as const;

export type ErrorCodeEnum = typeof ErrorCodeEnum[keyof typeof ErrorCodeEnum];


/**
 * 
 * @export
 * @interface GETNotBookedTimeResponse
 */
export interface GETNotBookedTimeResponse {
    /**
     * Time periods
     * @type {Array<NotBookedTimePeriod>}
     * @memberof GETNotBookedTimeResponse
     */
    'timePeriods': Array<NotBookedTimePeriod>;
}
/**
 * 
 * @export
 * @interface GETProjectResponse
 */
export interface GETProjectResponse {
    /**
     * 
     * @type {Array<ProjectNameIDMap>}
     * @memberof GETProjectResponse
     */
    'projects'?: Array<ProjectNameIDMap>;
}
/**
 * 
 * @export
 * @interface GETProjectTimeSpansResponse
 */
export interface GETProjectTimeSpansResponse {
    /**
     * Array of time spans
     * @type {Array<ProjectDateTimeSpans>}
     * @memberof GETProjectTimeSpansResponse
     */
    'projectTimeSpans'?: Array<ProjectDateTimeSpans>;
}
/**
 * 
 * @export
 * @interface GETTimeBookingResponse
 */
export interface GETTimeBookingResponse {
    /**
     * 
     * @type {Array<TimeSpanWithID>}
     * @memberof GETTimeBookingResponse
     */
    'timeSpans'?: Array<TimeSpanWithID>;
}
/**
 * 
 * @export
 * @interface GETUserinfoResponse
 */
export interface GETUserinfoResponse {
    /**
     * 
     * @type {string}
     * @memberof GETUserinfoResponse
     */
    'email': string;
}
/**
 * Time periods that has no booking
 * @export
 * @interface NotBookedTimePeriod
 */
export interface NotBookedTimePeriod {
    /**
     * Date of time period e.g. 2022-01-30
     * @type {string}
     * @memberof NotBookedTimePeriod
     */
    'date': string;
    /**
     * Array of time periods
     * @type {Array<TimePeriod>}
     * @memberof NotBookedTimePeriod
     */
    'timePeriods': Array<TimePeriod>;
}
/**
 * Off-duty reason
 * @export
 * @enum {string}
 */

export const OffDutyReasonEnum = {
    ChildbirthOfPartner: 'CHILDBIRTH_OF_PARTNER',
    DeceaseOfPartner: 'DECEASE_OF_PARTNER',
    DeceaseOfPartnerSameHousehold: 'DECEASE_OF_PARTNER_SAME_HOUSEHOLD',
    DeceaseOfParent: 'DECEASE_OF_PARENT',
    DeceaseOfChild: 'DECEASE_OF_CHILD',
    DeceaseOfSiblingGrandparentParentsInLaw: 'DECEASE_OF_SIBLING_GRANDPARENT_PARENTS_IN_LAW',
    MarriagePartnership: 'MARRIAGE_PARTNERSHIP',
    MarriagePartnershipOfSiblingChildParent: 'MARRIAGE_PARTNERSHIP_OF_SIBLING_CHILD_PARENT',
    ChangeOfResidence: 'CHANGE_OF_RESIDENCE',
    Other: 'OTHER'
} as const;

export type OffDutyReasonEnum = typeof OffDutyReasonEnum[keyof typeof OffDutyReasonEnum];


/**
 * 
 * @export
 * @interface PUTPOSTProjectTimeSpansRequest
 */
export interface PUTPOSTProjectTimeSpansRequest {
    /**
     * Date of project time span e.g. 2022-01-30
     * @type {string}
     * @memberof PUTPOSTProjectTimeSpansRequest
     */
    'date': string;
    /**
     * Project ID
     * @type {number}
     * @memberof PUTPOSTProjectTimeSpansRequest
     */
    'project': number;
    /**
     * Timespans
     * @type {Array<ProjectTimeSpan>}
     * @memberof PUTPOSTProjectTimeSpansRequest
     */
    'timeSpans': Array<ProjectTimeSpan>;
}
/**
 * 
 * @export
 * @interface PUTTimeBookingRequest
 */
export interface PUTTimeBookingRequest {
    /**
     * 
     * @type {Array<PUTTimeBookingTimeSpan>}
     * @memberof PUTTimeBookingRequest
     */
    'timeSpans'?: Array<PUTTimeBookingTimeSpan>;
}
/**
 * 
 * @export
 * @interface PUTTimeBookingTimeSpan
 */
export interface PUTTimeBookingTimeSpan {
    /**
     * 
     * @type {TimeSpanTypeEnum}
     * @memberof PUTTimeBookingTimeSpan
     */
    'type': TimeSpanTypeEnum;
    /**
     * Date of timebooking span
     * @type {string}
     * @memberof PUTTimeBookingTimeSpan
     */
    'date'?: string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof PUTTimeBookingTimeSpan
     */
    'toTime'?: string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof PUTTimeBookingTimeSpan
     */
    'fromTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof PUTTimeBookingTimeSpan
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface PatchTimeBookingCommitResponse
 */
export interface PatchTimeBookingCommitResponse {
    /**
     * 
     * @type {Array<TimeBookingLockDate>}
     * @memberof PatchTimeBookingCommitResponse
     */
    'locks': Array<TimeBookingLockDate>;
}
/**
 * Project date time spans
 * @export
 * @interface ProjectDateTimeSpans
 */
export interface ProjectDateTimeSpans {
    /**
     * Date of project date time spans
     * @type {string}
     * @memberof ProjectDateTimeSpans
     */
    'date': string;
    /**
     * Project ID
     * @type {number}
     * @memberof ProjectDateTimeSpans
     */
    'project': number;
    /**
     * Timespans
     * @type {Array<ProjectTimeSpan>}
     * @memberof ProjectDateTimeSpans
     */
    'timeSpans': Array<ProjectTimeSpan>;
    /**
     * Enables/disables the user lock. The user lock is used to lock a given date span for the current user. This prohibits any further editing of timebookings.
     * @type {boolean}
     * @memberof ProjectDateTimeSpans
     */
    'userlock'?: boolean;
    /**
     * Enables/disables the boss lock. The boss lock is used by the admin to lock and finalize a given date span for a user. This prohibits any further editing of timebookings by the user.
     * @type {boolean}
     * @memberof ProjectDateTimeSpans
     */
    'bosslock'?: boolean;
}
/**
 * Project name and ID map
 * @export
 * @interface ProjectNameIDMap
 */
export interface ProjectNameIDMap {
    /**
     * Project ID
     * @type {number}
     * @memberof ProjectNameIDMap
     */
    'projectId'?: number;
    /**
     * Project name
     * @type {string}
     * @memberof ProjectNameIDMap
     */
    'projectName'?: string;
}
/**
 * 
 * @export
 * @interface ProjectTimeSpan
 */
export interface ProjectTimeSpan {
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof ProjectTimeSpan
     */
    'fromTime': string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof ProjectTimeSpan
     */
    'toTime': string;
    /**
     * Comment for project time span
     * @type {string}
     * @memberof ProjectTimeSpan
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface TimeBookingError
 */
export interface TimeBookingError {
    /**
     * Error message
     * @type {string}
     * @memberof TimeBookingError
     */
    'message'?: string;
    /**
     * 
     * @type {ErrorCodeEnum}
     * @memberof TimeBookingError
     */
    'code': ErrorCodeEnum;
}
/**
 * 
 * @export
 * @interface TimeBookingLockDate
 */
export interface TimeBookingLockDate {
    /**
     * Enables/disables the user lock. The user lock is used to lock a given date span for the current user. This prohibits any further editing of timebookings.
     * @type {boolean}
     * @memberof TimeBookingLockDate
     */
    'userlock': boolean;
    /**
     * Enables/disables the boss lock. The boss lock is used by the admin to lock and finalize a given date span for a user. This prohibits any further editing of timebookings by the user.
     * @type {boolean}
     * @memberof TimeBookingLockDate
     */
    'bosslock': boolean;
    /**
     * Example: 2022-12-31
     * @type {string}
     * @memberof TimeBookingLockDate
     */
    'date': string;
    /**
     * Employee ID
     * @type {number}
     * @memberof TimeBookingLockDate
     */
    'employee': number;
}
/**
 * 
 * @export
 * @interface TimePeriod
 */
export interface TimePeriod {
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimePeriod
     */
    'fromTime': string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimePeriod
     */
    'toTime': string;
}
/**
 * Enum for timespan types
 * @export
 * @enum {string}
 */

export const TimeSpanTypeEnum = {
    Work: 'WORK',
    FullDayVacation: 'FULL_DAY_VACATION',
    HalfDayVacation: 'HALF_DAY_VACATION',
    SickLeave: 'SICK_LEAVE',
    Break: 'BREAK',
    OffDuty: 'OFF_DUTY',
    OnCallDuty: 'ON_CALL_DUTY',
    SpecialWork: 'SPECIAL_WORK'
} as const;

export type TimeSpanTypeEnum = typeof TimeSpanTypeEnum[keyof typeof TimeSpanTypeEnum];


/**
 * Time span object with ID
 * @export
 * @interface TimeSpanWithID
 */
export interface TimeSpanWithID {
    /**
     * Enables/disables the user lock. The user lock is used to lock a given date span for the current user. This prohibits any further editing of timebookings.
     * @type {boolean}
     * @memberof TimeSpanWithID
     */
    'userlock'?: boolean;
    /**
     * Enables/disables the boss lock. The boss lock is used by the admin to lock and finalize a given date span for a user. This prohibits any further editing of timebookings by the user.
     * @type {boolean}
     * @memberof TimeSpanWithID
     */
    'bosslock'?: boolean;
    /**
     * Time span ID
     * @type {number}
     * @memberof TimeSpanWithID
     */
    'id': number;
    /**
     * Date e.g. 2022-01-30
     * @type {string}
     * @memberof TimeSpanWithID
     */
    'date': string;
    /**
     * 
     * @type {TimeSpanTypeEnum}
     * @memberof TimeSpanWithID
     */
    'type': TimeSpanTypeEnum;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimeSpanWithID
     */
    'fromTime'?: string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimeSpanWithID
     */
    'toTime'?: string;
    /**
     * Whether this time has been spent in Homeoffice or not
     * @type {boolean}
     * @memberof TimeSpanWithID
     */
    'homeoffice'?: boolean;
    /**
     * 
     * @type {OffDutyReasonEnum}
     * @memberof TimeSpanWithID
     */
    'offDutyReason'?: OffDutyReasonEnum;
}
/**
 * 
 * @export
 * @interface TimeSpanWithIDAllOf
 */
export interface TimeSpanWithIDAllOf {
    /**
     * Enables/disables the user lock. The user lock is used to lock a given date span for the current user. This prohibits any further editing of timebookings.
     * @type {boolean}
     * @memberof TimeSpanWithIDAllOf
     */
    'userlock'?: boolean;
    /**
     * Enables/disables the boss lock. The boss lock is used by the admin to lock and finalize a given date span for a user. This prohibits any further editing of timebookings by the user.
     * @type {boolean}
     * @memberof TimeSpanWithIDAllOf
     */
    'bosslock'?: boolean;
    /**
     * Time span ID
     * @type {number}
     * @memberof TimeSpanWithIDAllOf
     */
    'id': number;
}
/**
 * Timespan object without ID
 * @export
 * @interface TimeSpanWithoutID
 */
export interface TimeSpanWithoutID {
    /**
     * Date e.g. 2022-01-30
     * @type {string}
     * @memberof TimeSpanWithoutID
     */
    'date': string;
    /**
     * 
     * @type {TimeSpanTypeEnum}
     * @memberof TimeSpanWithoutID
     */
    'type': TimeSpanTypeEnum;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimeSpanWithoutID
     */
    'fromTime'?: string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimeSpanWithoutID
     */
    'toTime'?: string;
    /**
     * Whether this time has been spent in Homeoffice or not
     * @type {boolean}
     * @memberof TimeSpanWithoutID
     */
    'homeoffice'?: boolean;
    /**
     * 
     * @type {OffDutyReasonEnum}
     * @memberof TimeSpanWithoutID
     */
    'offDutyReason'?: OffDutyReasonEnum;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export timebookings as CSV file
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [exportEmployeeId] ID of employee to export CSV for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csvGet: async (fromDate: string, toDate: string, exportEmployeeId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('csvGet', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('csvGet', 'toDate', toDate)
            const localVarPath = `/csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }

            if (exportEmployeeId !== undefined) {
                localVarQueryParameter['exportEmployeeId'] = exportEmployeeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all available projects to book time on for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project time booking
         * @param {string} day Date of project time e.g. 2022-01-30
         * @param {number} [project] Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingDelete: async (day: string, project?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'day' is not null or undefined
            assertParamExists('projectTimeBookingDelete', 'day', day)
            const localVarPath = `/project-time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (day !== undefined) {
                localVarQueryParameter['day'] = (day as any instanceof Date) ?
                    (day as any).toISOString().substr(0,10) :
                    day;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project timespans within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingGet: async (fromDate: string, toDate: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('projectTimeBookingGet', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('projectTimeBookingGet', 'toDate', toDate)
            const localVarPath = `/project-time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all non-booked time periods within from and to date
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingNotBookedGet: async (fromDate: string, toDate: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('projectTimeBookingNotBookedGet', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('projectTimeBookingNotBookedGet', 'toDate', toDate)
            const localVarPath = `/project-time-booking/not-booked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Saves project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingPost: async (pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pUTPOSTProjectTimeSpansRequest' is not null or undefined
            assertParamExists('projectTimeBookingPost', 'pUTPOSTProjectTimeSpansRequest', pUTPOSTProjectTimeSpansRequest)
            const localVarPath = `/project-time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pUTPOSTProjectTimeSpansRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingPut: async (pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pUTPOSTProjectTimeSpansRequest' is not null or undefined
            assertParamExists('projectTimeBookingPut', 'pUTPOSTProjectTimeSpansRequest', pUTPOSTProjectTimeSpansRequest)
            const localVarPath = `/project-time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pUTPOSTProjectTimeSpansRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit/withdraw time booking
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {boolean} [boss] Sets the boss lock
         * @param {boolean} [withdraw] Un-do the submit of the current timesheet by setting withdraw to true
         * @param {number} [employee] Employee ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingCommitPatch: async (fromDate: string, toDate: string, boss?: boolean, withdraw?: boolean, employee?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('timeBookingCommitPatch', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('timeBookingCommitPatch', 'toDate', toDate)
            const localVarPath = `/time-booking/commit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (boss !== undefined) {
                localVarQueryParameter['boss'] = boss;
            }

            if (withdraw !== undefined) {
                localVarQueryParameter['withdraw'] = withdraw;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }

            if (employee !== undefined) {
                localVarQueryParameter['employee'] = employee;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get time bookings within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [employeeId] Access timebooking of another employee. Only allowed for boss. Example: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingGet: async (fromDate: string, toDate: string, employeeId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('timeBookingGet', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('timeBookingGet', 'toDate', toDate)
            const localVarPath = `/time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save a time booking
         * @param {TimeSpanWithoutID} timeSpanWithoutID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingPost: async (timeSpanWithoutID: TimeSpanWithoutID, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSpanWithoutID' is not null or undefined
            assertParamExists('timeBookingPost', 'timeSpanWithoutID', timeSpanWithoutID)
            const localVarPath = `/time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSpanWithoutID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdDelete: async (timeSpanId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSpanId' is not null or undefined
            assertParamExists('timeBookingTimeSpanIdDelete', 'timeSpanId', timeSpanId)
            const localVarPath = `/time-booking/{timeSpanId}`
                .replace(`{${"timeSpanId"}}`, encodeURIComponent(String(timeSpanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdGet: async (timeSpanId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSpanId' is not null or undefined
            assertParamExists('timeBookingTimeSpanIdGet', 'timeSpanId', timeSpanId)
            const localVarPath = `/time-booking/{timeSpanId}`
                .replace(`{${"timeSpanId"}}`, encodeURIComponent(String(timeSpanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update time span
         * @param {number} timeSpanId 
         * @param {TimeSpanWithoutID} [timeSpanWithoutID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdPut: async (timeSpanId: number, timeSpanWithoutID?: TimeSpanWithoutID, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSpanId' is not null or undefined
            assertParamExists('timeBookingTimeSpanIdPut', 'timeSpanId', timeSpanId)
            const localVarPath = `/time-booking/{timeSpanId}`
                .replace(`{${"timeSpanId"}}`, encodeURIComponent(String(timeSpanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSpanWithoutID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information about the related employee with the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userinfo/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Export timebookings as CSV file
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [exportEmployeeId] ID of employee to export CSV for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async csvGet(fromDate: string, toDate: string, exportEmployeeId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.csvGet(fromDate, toDate, exportEmployeeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all available projects to book time on for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete project time booking
         * @param {string} day Date of project time e.g. 2022-01-30
         * @param {number} [project] Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingDelete(day: string, project?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DELETEProjectTimeBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingDelete(day, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get project timespans within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingGet(fromDate: string, toDate: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETProjectTimeSpansResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingGet(fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all non-booked time periods within from and to date
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingNotBookedGet(fromDate: string, toDate: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETNotBookedTimeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingNotBookedGet(fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Saves project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDateTimeSpans>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDateTimeSpans>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit/withdraw time booking
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {boolean} [boss] Sets the boss lock
         * @param {boolean} [withdraw] Un-do the submit of the current timesheet by setting withdraw to true
         * @param {number} [employee] Employee ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingCommitPatch(fromDate: string, toDate: string, boss?: boolean, withdraw?: boolean, employee?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PatchTimeBookingCommitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingCommitPatch(fromDate, toDate, boss, withdraw, employee, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get time bookings within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [employeeId] Access timebooking of another employee. Only allowed for boss. Example: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingGet(fromDate: string, toDate: string, employeeId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETTimeBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingGet(fromDate, toDate, employeeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save a time booking
         * @param {TimeSpanWithoutID} timeSpanWithoutID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingPost(timeSpanWithoutID: TimeSpanWithoutID, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSpanWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingPost(timeSpanWithoutID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingTimeSpanIdDelete(timeSpanId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSpanWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingTimeSpanIdDelete(timeSpanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingTimeSpanIdGet(timeSpanId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSpanWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingTimeSpanIdGet(timeSpanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update time span
         * @param {number} timeSpanId 
         * @param {TimeSpanWithoutID} [timeSpanWithoutID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingTimeSpanIdPut(timeSpanId: number, timeSpanWithoutID?: TimeSpanWithoutID, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSpanWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingTimeSpanIdPut(timeSpanId, timeSpanWithoutID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets information about the related employee with the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userinfoMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETUserinfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userinfoMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Export timebookings as CSV file
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [exportEmployeeId] ID of employee to export CSV for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csvGet(fromDate: string, toDate: string, exportEmployeeId?: number, options?: any): AxiosPromise<string> {
            return localVarFp.csvGet(fromDate, toDate, exportEmployeeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all available projects to book time on for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectGet(options?: any): AxiosPromise<GETProjectResponse> {
            return localVarFp.projectGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete project time booking
         * @param {string} day Date of project time e.g. 2022-01-30
         * @param {number} [project] Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingDelete(day: string, project?: number, options?: any): AxiosPromise<DELETEProjectTimeBookingResponse> {
            return localVarFp.projectTimeBookingDelete(day, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project timespans within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingGet(fromDate: string, toDate: string, options?: any): AxiosPromise<GETProjectTimeSpansResponse> {
            return localVarFp.projectTimeBookingGet(fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all non-booked time periods within from and to date
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingNotBookedGet(fromDate: string, toDate: string, options?: any): AxiosPromise<GETNotBookedTimeResponse> {
            return localVarFp.projectTimeBookingNotBookedGet(fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Saves project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: any): AxiosPromise<ProjectDateTimeSpans> {
            return localVarFp.projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: any): AxiosPromise<ProjectDateTimeSpans> {
            return localVarFp.projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit/withdraw time booking
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {boolean} [boss] Sets the boss lock
         * @param {boolean} [withdraw] Un-do the submit of the current timesheet by setting withdraw to true
         * @param {number} [employee] Employee ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingCommitPatch(fromDate: string, toDate: string, boss?: boolean, withdraw?: boolean, employee?: number, options?: any): AxiosPromise<PatchTimeBookingCommitResponse> {
            return localVarFp.timeBookingCommitPatch(fromDate, toDate, boss, withdraw, employee, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get time bookings within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [employeeId] Access timebooking of another employee. Only allowed for boss. Example: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingGet(fromDate: string, toDate: string, employeeId?: number, options?: any): AxiosPromise<GETTimeBookingResponse> {
            return localVarFp.timeBookingGet(fromDate, toDate, employeeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save a time booking
         * @param {TimeSpanWithoutID} timeSpanWithoutID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingPost(timeSpanWithoutID: TimeSpanWithoutID, options?: any): AxiosPromise<TimeSpanWithID> {
            return localVarFp.timeBookingPost(timeSpanWithoutID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdDelete(timeSpanId: number, options?: any): AxiosPromise<TimeSpanWithID> {
            return localVarFp.timeBookingTimeSpanIdDelete(timeSpanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdGet(timeSpanId: number, options?: any): AxiosPromise<TimeSpanWithID> {
            return localVarFp.timeBookingTimeSpanIdGet(timeSpanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update time span
         * @param {number} timeSpanId 
         * @param {TimeSpanWithoutID} [timeSpanWithoutID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdPut(timeSpanId: number, timeSpanWithoutID?: TimeSpanWithoutID, options?: any): AxiosPromise<TimeSpanWithID> {
            return localVarFp.timeBookingTimeSpanIdPut(timeSpanId, timeSpanWithoutID, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets information about the related employee with the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoMeGet(options?: any): AxiosPromise<GETUserinfoResponse> {
            return localVarFp.userinfoMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Export timebookings as CSV file
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {number} [exportEmployeeId] ID of employee to export CSV for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public csvGet(fromDate: string, toDate: string, exportEmployeeId?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).csvGet(fromDate, toDate, exportEmployeeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all available projects to book time on for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete project time booking
     * @param {string} day Date of project time e.g. 2022-01-30
     * @param {number} [project] Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTimeBookingDelete(day: string, project?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectTimeBookingDelete(day, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project timespans within a date range (from-to)
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTimeBookingGet(fromDate: string, toDate: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectTimeBookingGet(fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all non-booked time periods within from and to date
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTimeBookingNotBookedGet(fromDate: string, toDate: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectTimeBookingNotBookedGet(fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Saves project time booking
     * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project time booking
     * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit/withdraw time booking
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {boolean} [boss] Sets the boss lock
     * @param {boolean} [withdraw] Un-do the submit of the current timesheet by setting withdraw to true
     * @param {number} [employee] Employee ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeBookingCommitPatch(fromDate: string, toDate: string, boss?: boolean, withdraw?: boolean, employee?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).timeBookingCommitPatch(fromDate, toDate, boss, withdraw, employee, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get time bookings within a date range (from-to)
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {number} [employeeId] Access timebooking of another employee. Only allowed for boss. Example: 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeBookingGet(fromDate: string, toDate: string, employeeId?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).timeBookingGet(fromDate, toDate, employeeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save a time booking
     * @param {TimeSpanWithoutID} timeSpanWithoutID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeBookingPost(timeSpanWithoutID: TimeSpanWithoutID, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).timeBookingPost(timeSpanWithoutID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete time booking by ID
     * @param {number} timeSpanId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeBookingTimeSpanIdDelete(timeSpanId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).timeBookingTimeSpanIdDelete(timeSpanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get time booking by ID
     * @param {number} timeSpanId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeBookingTimeSpanIdGet(timeSpanId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).timeBookingTimeSpanIdGet(timeSpanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update time span
     * @param {number} timeSpanId 
     * @param {TimeSpanWithoutID} [timeSpanWithoutID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeBookingTimeSpanIdPut(timeSpanId: number, timeSpanWithoutID?: TimeSpanWithoutID, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).timeBookingTimeSpanIdPut(timeSpanId, timeSpanWithoutID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets information about the related employee with the api key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userinfoMeGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userinfoMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


