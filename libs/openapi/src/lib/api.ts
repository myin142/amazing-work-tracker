/* tslint:disable */
/* eslint-disable */
/**
 * Time Booking
 * Time Booking API for IMS
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: tobias.demmer@it-experts.at
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface DELETEProjectTimeBookingResponse
 */
export interface DELETEProjectTimeBookingResponse {
    /**
     * Project time spans
     * @type {Array<ProjectDateTimeSpans>}
     * @memberof DELETEProjectTimeBookingResponse
     */
    'projectTimeSpans'?: Array<ProjectDateTimeSpans>;
}
/**
 * 
 * @export
 * @interface GETHolidaysResponse
 */
export interface GETHolidaysResponse {
    /**
     * 
     * @type {Array<HolidayInfo>}
     * @memberof GETHolidaysResponse
     */
    'holidays': Array<HolidayInfo>;
}
/**
 * 
 * @export
 * @interface GETMonthWorkHoursDifferenceResponse
 */
export interface GETMonthWorkHoursDifferenceResponse {
    /**
     * Amount of hours difference between \"SOLL\" and \"IST\". Positive value -> having greater \"IST\" than \"SOLL\". Negative value -> having greater \"SOLL\" than \"IST\". 
     * @type {number}
     * @memberof GETMonthWorkHoursDifferenceResponse
     */
    'workHoursDifference': number;
}
/**
 * 
 * @export
 * @interface GETNotBookedTimeResponse
 */
export interface GETNotBookedTimeResponse {
    /**
     * Time periods
     * @type {Array<NotBookedTimePeriod>}
     * @memberof GETNotBookedTimeResponse
     */
    'timePeriods': Array<NotBookedTimePeriod>;
}
/**
 * 
 * @export
 * @interface GETProjectResponse
 */
export interface GETProjectResponse {
    /**
     * 
     * @type {Array<ProjectNameIDMap>}
     * @memberof GETProjectResponse
     */
    'projects'?: Array<ProjectNameIDMap>;
}
/**
 * 
 * @export
 * @interface GETProjectTimeSpansResponse
 */
export interface GETProjectTimeSpansResponse {
    /**
     * Array of time spans
     * @type {Array<ProjectDateTimeSpans>}
     * @memberof GETProjectTimeSpansResponse
     */
    'projectTimeSpans'?: Array<ProjectDateTimeSpans>;
}
/**
 * 
 * @export
 * @interface GETTimeBookingResponse
 */
export interface GETTimeBookingResponse {
    /**
     * 
     * @type {Array<TimeSpanWithID>}
     * @memberof GETTimeBookingResponse
     */
    'timeSpans'?: Array<TimeSpanWithID>;
}
/**
 * 
 * @export
 * @interface GETUserinfoResponse
 */
export interface GETUserinfoResponse {
    /**
     * 
     * @type {string}
     * @memberof GETUserinfoResponse
     */
    'email': string;
}
/**
 * Information about a holiday
 * @export
 * @interface HolidayInfo
 */
export interface HolidayInfo {
    /**
     * The name of the holiday
     * @type {string}
     * @memberof HolidayInfo
     */
    'name': string;
    /**
     * The date of the holiday
     * @type {string}
     * @memberof HolidayInfo
     */
    'date': string;
    /**
     * If the holiday is Workable, this means that it is a half-day
     * @type {boolean}
     * @memberof HolidayInfo
     */
    'workable': boolean;
}
/**
 * Time periods that has no booking
 * @export
 * @interface NotBookedTimePeriod
 */
export interface NotBookedTimePeriod {
    /**
     * Date of time period e.g. 2022-01-30
     * @type {string}
     * @memberof NotBookedTimePeriod
     */
    'date': string;
    /**
     * Array of time periods
     * @type {Array<TimePeriod>}
     * @memberof NotBookedTimePeriod
     */
    'timePeriods': Array<TimePeriod>;
}
/**
 * 
 * @export
 * @interface PUTPOSTProjectTimeSpansRequest
 */
export interface PUTPOSTProjectTimeSpansRequest {
    /**
     * Date of project time span e.g. 2022-01-30
     * @type {string}
     * @memberof PUTPOSTProjectTimeSpansRequest
     */
    'date': string;
    /**
     * Project ID
     * @type {number}
     * @memberof PUTPOSTProjectTimeSpansRequest
     */
    'project': number;
    /**
     * Timespans
     * @type {Array<ProjectTimeSpan>}
     * @memberof PUTPOSTProjectTimeSpansRequest
     */
    'timeSpans': Array<ProjectTimeSpan>;
}
/**
 * 
 * @export
 * @interface PatchTimeBookingCommitResponse
 */
export interface PatchTimeBookingCommitResponse {
    /**
     * 
     * @type {Array<TimeBookingLockDate>}
     * @memberof PatchTimeBookingCommitResponse
     */
    'locks': Array<TimeBookingLockDate>;
}
/**
 * Project date time spans
 * @export
 * @interface ProjectDateTimeSpans
 */
export interface ProjectDateTimeSpans {
    /**
     * Date of project date time spans
     * @type {string}
     * @memberof ProjectDateTimeSpans
     */
    'date': string;
    /**
     * Project ID
     * @type {number}
     * @memberof ProjectDateTimeSpans
     */
    'project': number;
    /**
     * Timespans
     * @type {Array<ProjectTimeSpan>}
     * @memberof ProjectDateTimeSpans
     */
    'timeSpans': Array<ProjectTimeSpan>;
    /**
     * Enables/disables the user lock. The user lock is used to lock a given date span for the current user. This prohibits any further editing of timebookings.
     * @type {boolean}
     * @memberof ProjectDateTimeSpans
     */
    'userlock'?: boolean;
    /**
     * Enables/disables the boss lock. The boss lock is used by the admin to lock and finalize a given date span for a user. This prohibits any further editing of timebookings by the user.
     * @type {boolean}
     * @memberof ProjectDateTimeSpans
     */
    'bosslock'?: boolean;
}
/**
 * Project name and ID map
 * @export
 * @interface ProjectNameIDMap
 */
export interface ProjectNameIDMap {
    /**
     * Project ID
     * @type {number}
     * @memberof ProjectNameIDMap
     */
    'projectId'?: number;
    /**
     * Project name
     * @type {string}
     * @memberof ProjectNameIDMap
     */
    'projectName'?: string;
}
/**
 * Timespans
 * @export
 * @interface ProjectTimeSpan
 */
export interface ProjectTimeSpan {
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof ProjectTimeSpan
     */
    'fromTime': string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof ProjectTimeSpan
     */
    'toTime': string;
    /**
     * Comment for project time span
     * @type {string}
     * @memberof ProjectTimeSpan
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface TimeBookingError
 */
export interface TimeBookingError {
    /**
     * Error message
     * @type {string}
     * @memberof TimeBookingError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeBookingError
     */
    'code': TimeBookingErrorCodeEnum;
}

export const TimeBookingErrorCodeEnum = {
    ExistingProjectBookings: 'EXISTING_PROJECT_BOOKINGS',
    OverlappingTime: 'OVERLAPPING_TIME',
    TimeOutOfBounds: 'TIME_OUT_OF_BOUNDS',
    TimeLimitExceeded: 'TIME_LIMIT_EXCEEDED',
    IllegalTimeBounds: 'ILLEGAL_TIME_BOUNDS',
    UnbookedTime: 'UNBOOKED_TIME',
    OperationNotPermitted: 'OPERATION_NOT_PERMITTED',
    IllegalDate: 'ILLEGAL_DATE',
    ValidationError: 'VALIDATION_ERROR',
    ExistingVacation: 'EXISTING_VACATION',
    ExistingOffDuty: 'EXISTING_OFF_DUTY',
    ExistingSickLeave: 'EXISTING_SICK_LEAVE',
    ExistingTimeBookingEntries: 'EXISTING_TIME_BOOKING_ENTRIES',
    UserLocked: 'USER_LOCKED',
    BossLocked: 'BOSS_LOCKED',
    ProjectNotFound: 'PROJECT_NOT_FOUND'
} as const;

export type TimeBookingErrorCodeEnum = typeof TimeBookingErrorCodeEnum[keyof typeof TimeBookingErrorCodeEnum];

/**
 * 
 * @export
 * @interface TimeBookingLockDate
 */
export interface TimeBookingLockDate {
    /**
     * Enables/disables the user lock. The user lock is used to lock a given date span for the current user. This prohibits any further editing of timebookings.
     * @type {boolean}
     * @memberof TimeBookingLockDate
     */
    'userlock': boolean;
    /**
     * Enables/disables the boss lock. The boss lock is used by the admin to lock and finalize a given date span for a user. This prohibits any further editing of timebookings by the user.
     * @type {boolean}
     * @memberof TimeBookingLockDate
     */
    'bosslock': boolean;
    /**
     * Example: 2022-12-31
     * @type {string}
     * @memberof TimeBookingLockDate
     */
    'date': string;
    /**
     * Employee ID
     * @type {number}
     * @memberof TimeBookingLockDate
     */
    'employee': number;
}
/**
 * Array of time periods
 * @export
 * @interface TimePeriod
 */
export interface TimePeriod {
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimePeriod
     */
    'fromTime': string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimePeriod
     */
    'toTime': string;
}
/**
 * Time span object with ID
 * @export
 * @interface TimeSpanWithID
 */
export interface TimeSpanWithID {
    /**
     * Enables/disables the user lock. The user lock is used to lock a given date span for the current user. This prohibits any further editing of timebookings.
     * @type {boolean}
     * @memberof TimeSpanWithID
     */
    'userlock'?: boolean;
    /**
     * Enables/disables the boss lock. The boss lock is used by the admin to lock and finalize a given date span for a user. This prohibits any further editing of timebookings by the user.
     * @type {boolean}
     * @memberof TimeSpanWithID
     */
    'bosslock'?: boolean;
    /**
     * Time span ID
     * @type {number}
     * @memberof TimeSpanWithID
     */
    'id': number;
    /**
     * Date e.g. 2022-01-30
     * @type {string}
     * @memberof TimeSpanWithID
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSpanWithID
     */
    'type': TimeSpanWithIDTypeEnum;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimeSpanWithID
     */
    'fromTime'?: string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimeSpanWithID
     */
    'toTime'?: string;
    /**
     * Whether this time has been spent in Homeoffice or not
     * @type {boolean}
     * @memberof TimeSpanWithID
     */
    'homeoffice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TimeSpanWithID
     */
    'offDutyReason'?: TimeSpanWithIDOffDutyReasonEnum;
}

export const TimeSpanWithIDTypeEnum = {
    Work: 'WORK',
    FullDayVacation: 'FULL_DAY_VACATION',
    HalfDayVacation: 'HALF_DAY_VACATION',
    SickLeave: 'SICK_LEAVE',
    Break: 'BREAK',
    OffDuty: 'OFF_DUTY',
    OnCallDuty: 'ON_CALL_DUTY',
    SpecialWork: 'SPECIAL_WORK'
} as const;

export type TimeSpanWithIDTypeEnum = typeof TimeSpanWithIDTypeEnum[keyof typeof TimeSpanWithIDTypeEnum];
export const TimeSpanWithIDOffDutyReasonEnum = {
    ChildbirthOfPartner: 'CHILDBIRTH_OF_PARTNER',
    DeceaseOfPartner: 'DECEASE_OF_PARTNER',
    DeceaseOfPartnerSameHousehold: 'DECEASE_OF_PARTNER_SAME_HOUSEHOLD',
    DeceaseOfParent: 'DECEASE_OF_PARENT',
    DeceaseOfChild: 'DECEASE_OF_CHILD',
    DeceaseOfSiblingGrandparentParentsInLaw: 'DECEASE_OF_SIBLING_GRANDPARENT_PARENTS_IN_LAW',
    MarriagePartnership: 'MARRIAGE_PARTNERSHIP',
    MarriagePartnershipOfSiblingChildParent: 'MARRIAGE_PARTNERSHIP_OF_SIBLING_CHILD_PARENT',
    ChangeOfResidence: 'CHANGE_OF_RESIDENCE',
    Other: 'OTHER'
} as const;

export type TimeSpanWithIDOffDutyReasonEnum = typeof TimeSpanWithIDOffDutyReasonEnum[keyof typeof TimeSpanWithIDOffDutyReasonEnum];

/**
 * Timespan object without ID
 * @export
 * @interface TimeSpanWithoutID
 */
export interface TimeSpanWithoutID {
    /**
     * Date e.g. 2022-01-30
     * @type {string}
     * @memberof TimeSpanWithoutID
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSpanWithoutID
     */
    'type': TimeSpanWithoutIDTypeEnum;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimeSpanWithoutID
     */
    'fromTime'?: string;
    /**
     * Time Format in a 00:00 - 23:45 range, in 15 min units
     * @type {string}
     * @memberof TimeSpanWithoutID
     */
    'toTime'?: string;
    /**
     * Whether this time has been spent in Homeoffice or not
     * @type {boolean}
     * @memberof TimeSpanWithoutID
     */
    'homeoffice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TimeSpanWithoutID
     */
    'offDutyReason'?: TimeSpanWithoutIDOffDutyReasonEnum;
}

export const TimeSpanWithoutIDTypeEnum = {
    Work: 'WORK',
    FullDayVacation: 'FULL_DAY_VACATION',
    HalfDayVacation: 'HALF_DAY_VACATION',
    SickLeave: 'SICK_LEAVE',
    Break: 'BREAK',
    OffDuty: 'OFF_DUTY',
    OnCallDuty: 'ON_CALL_DUTY',
    SpecialWork: 'SPECIAL_WORK'
} as const;

export type TimeSpanWithoutIDTypeEnum = typeof TimeSpanWithoutIDTypeEnum[keyof typeof TimeSpanWithoutIDTypeEnum];
export const TimeSpanWithoutIDOffDutyReasonEnum = {
    ChildbirthOfPartner: 'CHILDBIRTH_OF_PARTNER',
    DeceaseOfPartner: 'DECEASE_OF_PARTNER',
    DeceaseOfPartnerSameHousehold: 'DECEASE_OF_PARTNER_SAME_HOUSEHOLD',
    DeceaseOfParent: 'DECEASE_OF_PARENT',
    DeceaseOfChild: 'DECEASE_OF_CHILD',
    DeceaseOfSiblingGrandparentParentsInLaw: 'DECEASE_OF_SIBLING_GRANDPARENT_PARENTS_IN_LAW',
    MarriagePartnership: 'MARRIAGE_PARTNERSHIP',
    MarriagePartnershipOfSiblingChildParent: 'MARRIAGE_PARTNERSHIP_OF_SIBLING_CHILD_PARENT',
    ChangeOfResidence: 'CHANGE_OF_RESIDENCE',
    Other: 'OTHER'
} as const;

export type TimeSpanWithoutIDOffDutyReasonEnum = typeof TimeSpanWithoutIDOffDutyReasonEnum[keyof typeof TimeSpanWithoutIDOffDutyReasonEnum];


/**
 * CsvApi - axios parameter creator
 * @export
 */
export const CsvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export timebookings as CSV file
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [exportEmployeeId] ID of employee to export CSV for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csvGet: async (fromDate: string, toDate: string, exportEmployeeId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('csvGet', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('csvGet', 'toDate', toDate)
            const localVarPath = `/api/v1/csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }

            if (exportEmployeeId !== undefined) {
                localVarQueryParameter['exportEmployeeId'] = exportEmployeeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CsvApi - functional programming interface
 * @export
 */
export const CsvApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CsvApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Export timebookings as CSV file
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [exportEmployeeId] ID of employee to export CSV for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async csvGet(fromDate: string, toDate: string, exportEmployeeId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.csvGet(fromDate, toDate, exportEmployeeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CsvApi - factory interface
 * @export
 */
export const CsvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CsvApiFp(configuration)
    return {
        /**
         * 
         * @summary Export timebookings as CSV file
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [exportEmployeeId] ID of employee to export CSV for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csvGet(fromDate: string, toDate: string, exportEmployeeId?: number, options?: any): AxiosPromise<string> {
            return localVarFp.csvGet(fromDate, toDate, exportEmployeeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CsvApi - object-oriented interface
 * @export
 * @class CsvApi
 * @extends {BaseAPI}
 */
export class CsvApi extends BaseAPI {
    /**
     * 
     * @summary Export timebookings as CSV file
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {number} [exportEmployeeId] ID of employee to export CSV for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CsvApi
     */
    public csvGet(fromDate: string, toDate: string, exportEmployeeId?: number, options?: AxiosRequestConfig) {
        return CsvApiFp(this.configuration).csvGet(fromDate, toDate, exportEmployeeId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HolidaysApi - axios parameter creator
 * @export
 */
export const HolidaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets Holiday information for the supplied year and month
         * @param {number} year 
         * @param {number} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holidaysYearMonthGet: async (year: number, month: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('holidaysYearMonthGet', 'year', year)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('holidaysYearMonthGet', 'month', month)
            const localVarPath = `/api/v1/holidays/{year}/{month}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HolidaysApi - functional programming interface
 * @export
 */
export const HolidaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HolidaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets Holiday information for the supplied year and month
         * @param {number} year 
         * @param {number} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holidaysYearMonthGet(year: number, month: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETHolidaysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holidaysYearMonthGet(year, month, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HolidaysApi - factory interface
 * @export
 */
export const HolidaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HolidaysApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets Holiday information for the supplied year and month
         * @param {number} year 
         * @param {number} month 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holidaysYearMonthGet(year: number, month: number, options?: any): AxiosPromise<GETHolidaysResponse> {
            return localVarFp.holidaysYearMonthGet(year, month, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HolidaysApi - object-oriented interface
 * @export
 * @class HolidaysApi
 * @extends {BaseAPI}
 */
export class HolidaysApi extends BaseAPI {
    /**
     * 
     * @summary Gets Holiday information for the supplied year and month
     * @param {number} year 
     * @param {number} month 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolidaysApi
     */
    public holidaysYearMonthGet(year: number, month: number, options?: AxiosRequestConfig) {
        return HolidaysApiFp(this.configuration).holidaysYearMonthGet(year, month, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MonthStatsApi - axios parameter creator
 * @export
 */
export const MonthStatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get working time difference (\"SOLL\"-\"IST\"-difference) in a given year-month, specified for the employee with the api key.
         * @param {number} year Specify the year of which the working time target is calculated
         * @param {number} month Specify the month of which the working time target is calculated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workHoursDifference: async (year: number, month: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('workHoursDifference', 'year', year)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('workHoursDifference', 'month', month)
            const localVarPath = `/api/v1/month-stats/work-hours-difference`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonthStatsApi - functional programming interface
 * @export
 */
export const MonthStatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonthStatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get working time difference (\"SOLL\"-\"IST\"-difference) in a given year-month, specified for the employee with the api key.
         * @param {number} year Specify the year of which the working time target is calculated
         * @param {number} month Specify the month of which the working time target is calculated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workHoursDifference(year: number, month: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETMonthWorkHoursDifferenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workHoursDifference(year, month, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MonthStatsApi - factory interface
 * @export
 */
export const MonthStatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonthStatsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get working time difference (\"SOLL\"-\"IST\"-difference) in a given year-month, specified for the employee with the api key.
         * @param {number} year Specify the year of which the working time target is calculated
         * @param {number} month Specify the month of which the working time target is calculated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workHoursDifference(year: number, month: number, options?: any): AxiosPromise<GETMonthWorkHoursDifferenceResponse> {
            return localVarFp.workHoursDifference(year, month, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonthStatsApi - object-oriented interface
 * @export
 * @class MonthStatsApi
 * @extends {BaseAPI}
 */
export class MonthStatsApi extends BaseAPI {
    /**
     * 
     * @summary Get working time difference (\"SOLL\"-\"IST\"-difference) in a given year-month, specified for the employee with the api key.
     * @param {number} year Specify the year of which the working time target is calculated
     * @param {number} month Specify the month of which the working time target is calculated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonthStatsApi
     */
    public workHoursDifference(year: number, month: number, options?: AxiosRequestConfig) {
        return MonthStatsApiFp(this.configuration).workHoursDifference(year, month, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all available projects to book time on for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all available projects to book time on for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all available projects to book time on for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectGet(options?: any): AxiosPromise<GETProjectResponse> {
            return localVarFp.projectGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Get all available projects to book time on for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectGet(options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).projectGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectTimeBookingApi - axios parameter creator
 * @export
 */
export const ProjectTimeBookingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete project time booking
         * @param {string} day Date of project time e.g. 2022-01-30
         * @param {number} [project] Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingDelete: async (day: string, project?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'day' is not null or undefined
            assertParamExists('projectTimeBookingDelete', 'day', day)
            const localVarPath = `/api/v1/project-time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (day !== undefined) {
                localVarQueryParameter['day'] = (day as any instanceof Date) ?
                    (day as any).toISOString().substr(0,10) :
                    day;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project timespans within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingGet: async (fromDate: string, toDate: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('projectTimeBookingGet', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('projectTimeBookingGet', 'toDate', toDate)
            const localVarPath = `/api/v1/project-time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all non-booked time periods within from and to date
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingNotBookedGet: async (fromDate: string, toDate: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('projectTimeBookingNotBookedGet', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('projectTimeBookingNotBookedGet', 'toDate', toDate)
            const localVarPath = `/api/v1/project-time-booking/not-booked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Saves project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingPost: async (pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pUTPOSTProjectTimeSpansRequest' is not null or undefined
            assertParamExists('projectTimeBookingPost', 'pUTPOSTProjectTimeSpansRequest', pUTPOSTProjectTimeSpansRequest)
            const localVarPath = `/api/v1/project-time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pUTPOSTProjectTimeSpansRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingPut: async (pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pUTPOSTProjectTimeSpansRequest' is not null or undefined
            assertParamExists('projectTimeBookingPut', 'pUTPOSTProjectTimeSpansRequest', pUTPOSTProjectTimeSpansRequest)
            const localVarPath = `/api/v1/project-time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pUTPOSTProjectTimeSpansRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectTimeBookingApi - functional programming interface
 * @export
 */
export const ProjectTimeBookingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectTimeBookingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete project time booking
         * @param {string} day Date of project time e.g. 2022-01-30
         * @param {number} [project] Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingDelete(day: string, project?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DELETEProjectTimeBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingDelete(day, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get project timespans within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingGet(fromDate: string, toDate: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETProjectTimeSpansResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingGet(fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all non-booked time periods within from and to date
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingNotBookedGet(fromDate: string, toDate: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETNotBookedTimeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingNotBookedGet(fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Saves project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDateTimeSpans>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDateTimeSpans>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectTimeBookingApi - factory interface
 * @export
 */
export const ProjectTimeBookingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectTimeBookingApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete project time booking
         * @param {string} day Date of project time e.g. 2022-01-30
         * @param {number} [project] Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingDelete(day: string, project?: number, options?: any): AxiosPromise<DELETEProjectTimeBookingResponse> {
            return localVarFp.projectTimeBookingDelete(day, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project timespans within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingGet(fromDate: string, toDate: string, options?: any): AxiosPromise<GETProjectTimeSpansResponse> {
            return localVarFp.projectTimeBookingGet(fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all non-booked time periods within from and to date
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingNotBookedGet(fromDate: string, toDate: string, options?: any): AxiosPromise<GETNotBookedTimeResponse> {
            return localVarFp.projectTimeBookingNotBookedGet(fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Saves project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: any): AxiosPromise<ProjectDateTimeSpans> {
            return localVarFp.projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project time booking
         * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: any): AxiosPromise<ProjectDateTimeSpans> {
            return localVarFp.projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectTimeBookingApi - object-oriented interface
 * @export
 * @class ProjectTimeBookingApi
 * @extends {BaseAPI}
 */
export class ProjectTimeBookingApi extends BaseAPI {
    /**
     * 
     * @summary Delete project time booking
     * @param {string} day Date of project time e.g. 2022-01-30
     * @param {number} [project] Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectTimeBookingApi
     */
    public projectTimeBookingDelete(day: string, project?: number, options?: AxiosRequestConfig) {
        return ProjectTimeBookingApiFp(this.configuration).projectTimeBookingDelete(day, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project timespans within a date range (from-to)
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectTimeBookingApi
     */
    public projectTimeBookingGet(fromDate: string, toDate: string, options?: AxiosRequestConfig) {
        return ProjectTimeBookingApiFp(this.configuration).projectTimeBookingGet(fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all non-booked time periods within from and to date
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectTimeBookingApi
     */
    public projectTimeBookingNotBookedGet(fromDate: string, toDate: string, options?: AxiosRequestConfig) {
        return ProjectTimeBookingApiFp(this.configuration).projectTimeBookingNotBookedGet(fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Saves project time booking
     * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectTimeBookingApi
     */
    public projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: AxiosRequestConfig) {
        return ProjectTimeBookingApiFp(this.configuration).projectTimeBookingPost(pUTPOSTProjectTimeSpansRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project time booking
     * @param {PUTPOSTProjectTimeSpansRequest} pUTPOSTProjectTimeSpansRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectTimeBookingApi
     */
    public projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest: PUTPOSTProjectTimeSpansRequest, options?: AxiosRequestConfig) {
        return ProjectTimeBookingApiFp(this.configuration).projectTimeBookingPut(pUTPOSTProjectTimeSpansRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimeBookingApi - axios parameter creator
 * @export
 */
export const TimeBookingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Submit/withdraw time booking
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {boolean} [boss] Sets the boss lock
         * @param {boolean} [withdraw] Un-do the submit of the current timesheet by setting withdraw to true
         * @param {number} [employee] Employee ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingCommitPatch: async (fromDate: string, toDate: string, boss?: boolean, withdraw?: boolean, employee?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('timeBookingCommitPatch', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('timeBookingCommitPatch', 'toDate', toDate)
            const localVarPath = `/api/v1/time-booking/commit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }

            if (boss !== undefined) {
                localVarQueryParameter['boss'] = boss;
            }

            if (withdraw !== undefined) {
                localVarQueryParameter['withdraw'] = withdraw;
            }

            if (employee !== undefined) {
                localVarQueryParameter['employee'] = employee;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get time bookings within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [employeeId] Access timebooking of another employee. Only allowed for boss. Example: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingGet: async (fromDate: string, toDate: string, employeeId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('timeBookingGet', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('timeBookingGet', 'toDate', toDate)
            const localVarPath = `/api/v1/time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substr(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substr(0,10) :
                    toDate;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save a time booking
         * @param {TimeSpanWithoutID} timeSpanWithoutID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingPost: async (timeSpanWithoutID: TimeSpanWithoutID, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSpanWithoutID' is not null or undefined
            assertParamExists('timeBookingPost', 'timeSpanWithoutID', timeSpanWithoutID)
            const localVarPath = `/api/v1/time-booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSpanWithoutID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdDelete: async (timeSpanId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSpanId' is not null or undefined
            assertParamExists('timeBookingTimeSpanIdDelete', 'timeSpanId', timeSpanId)
            const localVarPath = `/api/v1/time-booking/{timeSpanId}`
                .replace(`{${"timeSpanId"}}`, encodeURIComponent(String(timeSpanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdGet: async (timeSpanId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSpanId' is not null or undefined
            assertParamExists('timeBookingTimeSpanIdGet', 'timeSpanId', timeSpanId)
            const localVarPath = `/api/v1/time-booking/{timeSpanId}`
                .replace(`{${"timeSpanId"}}`, encodeURIComponent(String(timeSpanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update time span
         * @param {number} timeSpanId 
         * @param {TimeSpanWithoutID} [timeSpanWithoutID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdPut: async (timeSpanId: number, timeSpanWithoutID?: TimeSpanWithoutID, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSpanId' is not null or undefined
            assertParamExists('timeBookingTimeSpanIdPut', 'timeSpanId', timeSpanId)
            const localVarPath = `/api/v1/time-booking/{timeSpanId}`
                .replace(`{${"timeSpanId"}}`, encodeURIComponent(String(timeSpanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSpanWithoutID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeBookingApi - functional programming interface
 * @export
 */
export const TimeBookingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeBookingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Submit/withdraw time booking
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {boolean} [boss] Sets the boss lock
         * @param {boolean} [withdraw] Un-do the submit of the current timesheet by setting withdraw to true
         * @param {number} [employee] Employee ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingCommitPatch(fromDate: string, toDate: string, boss?: boolean, withdraw?: boolean, employee?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PatchTimeBookingCommitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingCommitPatch(fromDate, toDate, boss, withdraw, employee, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get time bookings within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [employeeId] Access timebooking of another employee. Only allowed for boss. Example: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingGet(fromDate: string, toDate: string, employeeId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETTimeBookingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingGet(fromDate, toDate, employeeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save a time booking
         * @param {TimeSpanWithoutID} timeSpanWithoutID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingPost(timeSpanWithoutID: TimeSpanWithoutID, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSpanWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingPost(timeSpanWithoutID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingTimeSpanIdDelete(timeSpanId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSpanWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingTimeSpanIdDelete(timeSpanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingTimeSpanIdGet(timeSpanId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSpanWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingTimeSpanIdGet(timeSpanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update time span
         * @param {number} timeSpanId 
         * @param {TimeSpanWithoutID} [timeSpanWithoutID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeBookingTimeSpanIdPut(timeSpanId: number, timeSpanWithoutID?: TimeSpanWithoutID, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSpanWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeBookingTimeSpanIdPut(timeSpanId, timeSpanWithoutID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimeBookingApi - factory interface
 * @export
 */
export const TimeBookingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeBookingApiFp(configuration)
    return {
        /**
         * 
         * @summary Submit/withdraw time booking
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {boolean} [boss] Sets the boss lock
         * @param {boolean} [withdraw] Un-do the submit of the current timesheet by setting withdraw to true
         * @param {number} [employee] Employee ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingCommitPatch(fromDate: string, toDate: string, boss?: boolean, withdraw?: boolean, employee?: number, options?: any): AxiosPromise<PatchTimeBookingCommitResponse> {
            return localVarFp.timeBookingCommitPatch(fromDate, toDate, boss, withdraw, employee, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get time bookings within a date range (from-to)
         * @param {string} fromDate Example: 2022-01-01
         * @param {string} toDate Example: 2022-01-31
         * @param {number} [employeeId] Access timebooking of another employee. Only allowed for boss. Example: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingGet(fromDate: string, toDate: string, employeeId?: number, options?: any): AxiosPromise<GETTimeBookingResponse> {
            return localVarFp.timeBookingGet(fromDate, toDate, employeeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save a time booking
         * @param {TimeSpanWithoutID} timeSpanWithoutID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingPost(timeSpanWithoutID: TimeSpanWithoutID, options?: any): AxiosPromise<TimeSpanWithID> {
            return localVarFp.timeBookingPost(timeSpanWithoutID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdDelete(timeSpanId: number, options?: any): AxiosPromise<TimeSpanWithID> {
            return localVarFp.timeBookingTimeSpanIdDelete(timeSpanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get time booking by ID
         * @param {number} timeSpanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdGet(timeSpanId: number, options?: any): AxiosPromise<TimeSpanWithID> {
            return localVarFp.timeBookingTimeSpanIdGet(timeSpanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update time span
         * @param {number} timeSpanId 
         * @param {TimeSpanWithoutID} [timeSpanWithoutID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeBookingTimeSpanIdPut(timeSpanId: number, timeSpanWithoutID?: TimeSpanWithoutID, options?: any): AxiosPromise<TimeSpanWithID> {
            return localVarFp.timeBookingTimeSpanIdPut(timeSpanId, timeSpanWithoutID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeBookingApi - object-oriented interface
 * @export
 * @class TimeBookingApi
 * @extends {BaseAPI}
 */
export class TimeBookingApi extends BaseAPI {
    /**
     * 
     * @summary Submit/withdraw time booking
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {boolean} [boss] Sets the boss lock
     * @param {boolean} [withdraw] Un-do the submit of the current timesheet by setting withdraw to true
     * @param {number} [employee] Employee ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeBookingApi
     */
    public timeBookingCommitPatch(fromDate: string, toDate: string, boss?: boolean, withdraw?: boolean, employee?: number, options?: AxiosRequestConfig) {
        return TimeBookingApiFp(this.configuration).timeBookingCommitPatch(fromDate, toDate, boss, withdraw, employee, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get time bookings within a date range (from-to)
     * @param {string} fromDate Example: 2022-01-01
     * @param {string} toDate Example: 2022-01-31
     * @param {number} [employeeId] Access timebooking of another employee. Only allowed for boss. Example: 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeBookingApi
     */
    public timeBookingGet(fromDate: string, toDate: string, employeeId?: number, options?: AxiosRequestConfig) {
        return TimeBookingApiFp(this.configuration).timeBookingGet(fromDate, toDate, employeeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save a time booking
     * @param {TimeSpanWithoutID} timeSpanWithoutID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeBookingApi
     */
    public timeBookingPost(timeSpanWithoutID: TimeSpanWithoutID, options?: AxiosRequestConfig) {
        return TimeBookingApiFp(this.configuration).timeBookingPost(timeSpanWithoutID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete time booking by ID
     * @param {number} timeSpanId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeBookingApi
     */
    public timeBookingTimeSpanIdDelete(timeSpanId: number, options?: AxiosRequestConfig) {
        return TimeBookingApiFp(this.configuration).timeBookingTimeSpanIdDelete(timeSpanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get time booking by ID
     * @param {number} timeSpanId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeBookingApi
     */
    public timeBookingTimeSpanIdGet(timeSpanId: number, options?: AxiosRequestConfig) {
        return TimeBookingApiFp(this.configuration).timeBookingTimeSpanIdGet(timeSpanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update time span
     * @param {number} timeSpanId 
     * @param {TimeSpanWithoutID} [timeSpanWithoutID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeBookingApi
     */
    public timeBookingTimeSpanIdPut(timeSpanId: number, timeSpanWithoutID?: TimeSpanWithoutID, options?: AxiosRequestConfig) {
        return TimeBookingApiFp(this.configuration).timeBookingTimeSpanIdPut(timeSpanId, timeSpanWithoutID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserinfoApi - axios parameter creator
 * @export
 */
export const UserinfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets information about the related employee with the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/userinfo/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserinfoApi - functional programming interface
 * @export
 */
export const UserinfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserinfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets information about the related employee with the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userinfoMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETUserinfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userinfoMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserinfoApi - factory interface
 * @export
 */
export const UserinfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserinfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets information about the related employee with the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoMeGet(options?: any): AxiosPromise<GETUserinfoResponse> {
            return localVarFp.userinfoMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserinfoApi - object-oriented interface
 * @export
 * @class UserinfoApi
 * @extends {BaseAPI}
 */
export class UserinfoApi extends BaseAPI {
    /**
     * 
     * @summary Gets information about the related employee with the api key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserinfoApi
     */
    public userinfoMeGet(options?: AxiosRequestConfig) {
        return UserinfoApiFp(this.configuration).userinfoMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


